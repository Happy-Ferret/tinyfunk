const{assign:e}=Object,t=e=>e.length,n=(e,r)=>e<1?r:(...c)=>{const p=e-t(c);return p>0?n(p,r.bind(null,...c)):r.apply(null,c)},r=n(2,n),c=e=>r(t(e),e),p=c((e,t)=>e+t),l=c((e,t)=>i(t,[e])),o=c((e,t)=>e.apply(null,t)),s=c((t,n,r)=>{const c=e({},r);return c[t]=n,c}),a=c(([e,...n],r,c)=>s(e,t(n)?a(n,r,c[e]):r,c)),u=r(2,(e,...t)=>o(e,t)),d=(...e)=>j(B(D))(e),i=c((e,t)=>e.concat(t)),h=c((e,t)=>d(o(e),v(t))),m=c((t,n)=>{const r=e({},n);return delete r[t],r}),y=c(([e,...n],r)=>e?null==r[e]?r:t(n)?s(e,y(n,r[e]),r):m(e,r):r),g=c((e,t,n)=>{let r=e[n]||f;return"object"==typeof r&&(r=b(r)),r(t)}),b=c((e,t)=>x(g(e),t)),j=c((e,t,n)=>c(e)(n,t)),f=e=>e,v=c((e,t)=>O(D(t),e)),O=c((e,t)=>t.map(e)),x=c((e,t)=>{const n={};for(let r in t)n[r]=e(t[r],r);return n}),P=c((e,t)=>t.match(e)||[]),R=c((t,n)=>e({},t,n)),w=c((e,t)=>e*t),z=c(([e,...n],r)=>t(n)?z(n,r[e]):r[e]),N=c((e,t)=>i([e],t)),k=c((e,t)=>t[e]),q=c((e,t)=>O(j(k)(t),e)),A=c((e,t,n)=>n.reduce(e,t)),B=c((e,t,n)=>n.reduceRight(e,t)),C=c((e,t,n)=>n.replace(e,t)),D=c((e,t)=>t(e)),E=c((e,t,n)=>e(n)?n:t(n)),F=c((e,t,n)=>e(n)?t(n):n),G=c((e,n)=>{const r={};for(let c=0;c<t(e);c++)r[e[c]]=n[c];return r});module.exports={add:p,append:l,apply:o,assoc:s,assocPath:a,call:u,compose:d,concat:i,constant:e=>()=>e,converge:h,curry:c,curryN:r,dissoc:m,dissocPath:y,evolve:b,flip:j,identity:f,juxt:v,length:t,map:O,mapObj:x,match:P,merge:R,multiply:w,path:z,pipe:(...e)=>j(A(D))(e),prepend:N,prop:k,props:q,reduce:A,reduceRight:B,replace:C,thrush:D,unless:E,when:F,zipObj:G};
